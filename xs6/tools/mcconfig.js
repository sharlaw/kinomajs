
import TOOL from "tool";
import * as FS from "fs";

class File {
	constructor(path) {
		this.fd = FS.openSync(path, "w");
		this.slash = "/";
	}
	close() {
		FS.closeSync(this.fd);
		delete this.fd;
	}
	line(...strings) {
		for (var string of strings)
			this.write(string);
		this.write("\n");
	}
	write(string) {
		FS.writeSync(this.fd, string);
	}
}

class MakeFile extends File {
	constructor(path) {
		super(path)
	}
	generate(tool) {
		this.line('# WARNING: This file is automatically generated by config. Do not edit. #');

		if (tool.debug)
			this.line("DEBUG = 1");
		this.line("XS_DIR = ", tool.xsPath);
		this.line("MC_DIR = ", tool.mcPath);
		
		this.line("BIN_DIR = ", tool.binPath);
		this.line("TMP_DIR = ", tool.tmpPath);
		this.line("DATA_DIR = ", tool.dataPath);
		this.line("MOD_DIR = ", tool.modPath);
		this.line("RESOURCES_DIR = ", tool.resourcesPath);
		
		this.write("C_INCLUDES =");
		this.write("\\\n\t-I$(XS_DIR)/includes");
		this.write("\\\n\t-I$(XS_DIR)/sources");
		if (tool.platform == "mac")
			this.write("\\\n\t-I$(XS_DIR)/sources/tool");
		else
			this.write("\\\n\t-I$(XS_DIR)/sources/pcre");
		this.write("\\\n\t-I$(MC_DIR)");
		for (var folder of tool.cFolders) {
			this.write("\\\n\t-I");
			this.write(folder);
		}
		this.write("\\\n\t-I$(MOD_DIR)");
		this.write("\\\n\t-I$(TMP_DIR)");
		this.line("");
		this.write("MODULES =");
		for (var result of tool.jsFiles) {
			this.write("\\\n\t$(MOD_DIR)/");
			this.write(result.target);
		}	
		this.line("");
		this.write("OBJECTS =");
		for (var result of tool.cFiles) {
			this.write("\\\n\t$(TMP_DIR)/");
			this.write(result.target);
		}	
		this.line("");
		this.write("DATA =");
		for (var result of tool.dataFiles) {
			this.write("\\\n\t$(DATA_DIR)/");
			this.write(result.target);
		}	
		this.line("");
		this.write("RESOURCES =");
		for (var result of tool.resourcesFiles) {
			this.write("\\\n\t$(RESOURCES_DIR)/");
			this.write(result.target);
		}	
		this.line("");
		this.line("");
		
		var path = tool.mcPath + "/manifest." + tool.platform + ".mk";
		this.write(FS.readFileSync(path));
		this.line("");
	
		for (var result of tool.jsFiles) {
			var source = result.source;
			var sourceParts = tool.splitPath(source);
			var target = result.target;
			var targetParts = tool.splitPath(target);
			if (sourceParts.name == targetParts.name) {
				this.line("$(MOD_DIR)/", target, ": ", source);
				if (tool.debug)
					this.line("\t$(XSC) -e -d -c -o $(@D) $<");
				else
					this.line("\t$(XSC) -e -c -o $(@D) $<");
			}
			else {
				this.line("$(MOD_DIR)/", target, ": $(TMP_DIR)/", sourceParts.name, ".xsb");
				this.line("\tcp $< $@");
				this.line("$(TMP_DIR)/", sourceParts.name, ".xsb: ", source);
				if (tool.debug)
					this.line("\t$(XSC) -e -d -c -o $(@D) $<");
				else
					this.line("\t$(XSC) -e -c -o $(@D) $<");
			}
		}

		for (var result of tool.cFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(TMP_DIR)/", target, ": ", source);
			this.line("\t$(CC) $< -c $(C_OPTIONS) $(C_INCLUDES) -o $@");
		}

		for (var result of tool.dataFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(DATA_DIR)/", target, ": ", source);
			this.line("\tcp $< $@");
		}

		for (var result of tool.resourcesFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(RESOURCES_DIR)/", target, ": ", source);
			this.line("\tcp $< $@");
		}
	}
}

class Rule {
	constructor(tool) {
		this.tool = tool;
	}
	appendFile(files, target, source, include) {
		if (!files.already[source]) {
			files.already[source] = true;
			if (include) {
				if (!files.find(file => file.target == target))
					files.push({ target, source });
			}
		}
	}
	appendFolder(folders, folder) {
		if (!folders.already[folder]) {
			folders.already[folder] = true;
			folders.push(folder);
		}
	}
	appendPath(target, path, include, prefix) {
	}
	appendSource(target, source, include, straight) {
	}
	appendTarget(target) {
	}
	process(property) {
		var tool = this.tool;
		var target = "~";
		if (target in property) {
			var sources = property[target];
			if (sources instanceof Array) {
				for (var source of sources) 
					this.iterate(target, source, false);
			}
			else
				this.iterate(target, sources, false);
		}
		for (var target in property) {
			var sources = property[target];
			if (target == "~") {
			}
			else {
				var slash = target.lastIndexOf("/");
				if (slash >= 0)
					this.appendTarget(target.slice(0, slash));
				var star = target.lastIndexOf("*");
				if (star >= 0) {
					target = target.slice(0, star);
					if (sources instanceof Array) {
						for (var source of sources) 
							this.iterate(target, tool.resolveVariable(source), true);
					}
					else
						this.iterate(target, tool.resolveVariable(sources), true);
				}
				else {
					this.appendSource(target, tool.resolveVariable(sources), true, true);
				}
			}
		}
	}
	iterate(target, source, include) {
		var star = source.lastIndexOf("*");
		if (star >= 0) {
			var slash = source.lastIndexOf("/");
			var directory = source.slice(0, slash);
			var prefix = source.slice(slash + 1, star);
			var names = FS.readDirSync(directory);
			var c = names.length;
			for (var i = 0; i < c; i++) {
				var name = names[i];
				if (!prefix || name.startsWith(prefix))
					this.appendPath(target, directory + "/" + name, include, prefix);
			}
		}
		else {
			this.appendSource(target, source, include, false);
		}
	}
};

class DataRule extends Rule {
	appendPath(target, path, include, prefix) {
		var tool = this.tool;
		var parts = tool.splitPath(path);
		this.appendFile(tool.dataFiles, target + parts.name.slice(prefix.length) + parts.extension, path, include);
	}
	appendSource(target, source, include, straight) {
		if (FS.existsSync(source) > 0) {
			var parts = tool.splitPath(source);
			this.appendFile(tool.dataFiles, straight ? target : target + parts.name + parts.extension, source, include);
		}
	}
};

class ModulesRule extends Rule {
	appendPath(target, path, include, prefix) {
		var tool = this.tool;
		var parts = tool.splitPath(path);
		if (parts.extension == ".js")
			this.appendFile(tool.jsFiles, target + parts.name.slice(prefix.length) + ".xsb", path, include);
		else if (parts.extension == ".c")
			this.appendFile(tool.cFiles, parts.name + ".o", path, include);
		else if (parts.extension == ".h")
			this.appendFolder(tool.cFolders, parts.directory, include);
	}
	appendSource(target, source, include, straight) {
		var tool = this.tool;
		var path = source + ".js";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFile(tool.jsFiles, straight ? target + ".xsb" : target + parts.name + ".xsb", path, include);
		}
		var path = source + ".c";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFile(tool.cFiles, parts.name + ".o", path, include);
		}
		var path = source + ".h";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFolder(tool.cFolders, parts.directory, include);
		}
	}
	appendTarget(target) {
		this.appendFolder(this.tool.jsFolders, target);
	}
};

class ResourcesRule extends Rule {
	appendPath(target, path, include, prefix) {
		var tool = this.tool;
		var parts = tool.splitPath(path);
		this.appendFile(tool.resourcesFiles, target + parts.name.slice(prefix.length) + parts.extension, path, include);
	}
	appendSource(target, source, include, straight) {
		if (FS.existsSync(source) > 0) {
			var parts = tool.splitPath(source);
			this.appendFile(tool.resourcesFiles, straight ? target : target + parts.name + parts.extension, source, include);
		}
	}
};

var platformNames = {
	k5: "k5",
	mac: "mac",
	macosx: "mac",
	MacOSX: "mac",
};

class Tool extends TOOL {
	constructor(argv) {
		super(argv);
		this.homePath = process.getenv("F_HOME");
		if (!this.homePath)
			throw new Error("F_HOME: variable not found!");
		this.xsPath = this.homePath + "/xs6";
		this.mcPath = this.xsPath + "/sources/mc";
			
		this.binPath = null;
		this.debug = false;
		this.make = false;
		this.manifestPath = null;
		this.outputPath = null;
		this.platform = null;
		this.tmpPath = null;
		this.windows = this.currentPlatform == "win";
		this.slash = this.windows ? "\\" : "/";
		
		var name, path;
		var argc = argv.length;
		for (var argi = 1; argi < argc; argi++) {
			var option = argv[argi];
			switch (option) {
			case "-d":
				this.debug = true;
				break;
			case "-m":
				this.make = true;
				break;
			case "-o":
				argi++;	
				if (argi >= argc)
					throw new Error("-o: no directory!");
				name = argv[argi];
				if (this.outputDirectory)
					throw new Error("-o '" + name + "': too many directories!");
				path = this.resolveDirectoryPath(name);
				if (!path)
					throw new Error("-o '" + name + "': directory not found!");
				this.outputPath = path;
				break;
			case "-p":
				argi++;	
				if (argi >= argc)
					throw new Error("-p: no platform!");
				name = argv[argi];
				if (this.platform)
					throw new Error("-p '" + name + "': too many platforms!");
				if (name in platformNames)
					name = platformNames[name];
				this.platform = name;
				break;
			default:
				name = argv[argi];
				if (this.manifestPath)
					throw new Error("'" + name + "': too many manifests!");
				path = this.resolveFilePath(name);
				if (!path)
					throw new Error("'" + name + "': manifest not found!");
				this.manifestPath = path;
				break;
			}
		}
		if (!this.manifestPath) {
			path = this.resolveFilePath("manifest.json");
			if (path)
				this.manifestPath = path;
			else
				throw new Error("no manifest!");
		}
		if (!this.outputPath)
			this.outputPath = this.homePath + "/xs6";
		if (!this.platform) {
			if (this.currentPlatform == "linux")
				this.platform = "linux/gtk";
			else
				this.platform = this.currentPlatform;
		}
		this.environment = {
			"F_HOME": this.homePath,
		}
	}
	createDirectories(path, first, last) {
		FS.mkdirSync(path);
		path += this.slash + first;
		FS.mkdirSync(path);
		let parts = this.platform.split("/");
		path += this.slash + parts[0];
		FS.mkdirSync(path);
		if (parts.length > 1) {
			path += this.slash + parts[1];
			FS.mkdirSync(path);
		}
		if (this.debug) 
			path += this.slash + "debug";
		else
			path += this.slash + "release";
		FS.mkdirSync(path);
		path += this.slash + last;
		FS.mkdirSync(path);
		return path;
	}
	filterItems(manifest, platform, name) {
		if (name in platform) {
			let targets = manifest[name];
			let sources = platform[name];
			manifest[name] = targets.concat(sources);
		}
	}
	filterManifest(manifest) {
		if (!("build" in manifest))
			manifest.build = {};
		if (!("data" in manifest))
			manifest.data = {};
		if (!("modules" in manifest))
			manifest.modules = {};
		if (!("resources" in manifest))
			manifest.resources = {};
		if ("platforms" in manifest) {
			let platforms = manifest.platforms;
			for (let name in platforms) {
				let value = platforms[name];
				if (name in platformNames)
					name = platformNames[name];
				if (this.platform == name) {
					this.filterPlatform(manifest, value);
				}
				else {
					name += "/";
					if (this.platform.indexOf(name) == 0) {
						this.filterPlatform(manifest, value);
						if ("platforms" in value) {
							let _platforms = value.platforms;
							for (let _name in _platforms) {
								let _value = _platforms[_name];
								if (_name in platformNames)
									_name = platformNames[_name];
								if (this.platform == name + _name) {
									this.filterPlatform(manifest, _value);
								}
							}
						}
					}
				}
			}
			delete manifest.platforms;
		}
		let properties = manifest.build;
		for (let name in properties) {
			let value = properties[name];
			if (typeof value == "string")
				this.environment[name] = this.resolveVariable(value);
			else
				this.environment[name] = value;
		}
	}
	filterPlatform(manifest, platform) {
		this.filterProperties(manifest, platform, "build");
		this.filterProperties(manifest, platform, "data");
		this.filterProperties(manifest, platform, "modules");
		this.filterProperties(manifest, platform, "resources");
	}
	filterProperties(manifest, platform, name) {
		if (name in platform) {
			let targets = manifest[name];
			let sources = platform[name];
			for (let name in sources) {
				let source = sources[name];
				if (source == null) 
					delete targets[name];
				else if (name in targets) {
					let target = targets[name];
					if (target instanceof Array)
						targets[name] = target.concat(source);
					else if (source instanceof Array)
						targets[name] = [target].concat(source);
					else
						targets[name] = source
				}
				else
					targets[name] = source
			}
		}
	}
	resolveVariable(value) {
		return value.replace(/\$\(([^\)]+)\)/g, (offset, value) => {
			if (value in this.environment)
				return this.environment[value];
			return process.getenv(value);
		});
	}
	run() {
		var path = this.manifestPath;
		var buffer = FS.readFileSync(path);
		var manifest = JSON.parse(buffer);
		this.filterManifest(manifest);
		this.dataFiles = [];
		this.dataFiles.already = {};
		this.jsFiles = [];
		this.jsFiles.already = {};
		this.jsFolders = [];
		this.jsFolders.already = {};
		this.cFiles = [];
		this.cFiles.already = {};
		this.cFolders = [];
		this.cFolders.already = {};
		this.resourcesFiles = [];
		this.resourcesFiles.already = {};
		var rule = new DataRule(this);
		rule.process(manifest.data);
		var rule = new ModulesRule(this);
		rule.process(manifest.modules);
		var rule = new ResourcesRule(this);
		rule.process(manifest.resources);
		if (!this.binPath)
			this.binPath = this.createDirectories(this.outputPath, "bin", (this.platform == "mac") ? "modules" : "mc");
		if (!this.tmpPath)
			this.tmpPath = this.createDirectories(this.outputPath, "tmp", "mc");
		this.modPath = this.tmpPath + "/modules";
		FS.mkdirSync(this.modPath);
		for (var folder of tool.jsFolders)
			FS.mkdirSync(this.modPath + "/" + folder);
		if (this.platform == "mac") {
			var path = this.resolveVariable("$(HOME)/tmp")
			FS.mkdirSync(path);
			this.dataPath = path + "/mc";
		}
		else
			this.dataPath = this.tmpPath + "/fs";
		FS.mkdirSync(this.dataPath);
		this.resourcesPath = this.tmpPath + "/resources";
		FS.mkdirSync(this.resourcesPath);
		var path = this.tmpPath + "/makefile";
		var file = new MakeFile(path);
		file.generate(this);
		if (this.make)
			process.then("make", "-f", path);
	}
}
	
		
var tool = new Tool(process.execArgv());
tool.run();
